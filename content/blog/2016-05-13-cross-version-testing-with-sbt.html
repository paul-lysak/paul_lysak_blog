---
layout: post
title: Cross-version testing with SBT
date: '2016-05-13T14:32:00.001+03:00'
author: Paul Lysak
tags:
- Play2
- Play
- testing
- Scala
- sbt
modified_time: '2016-05-13T14:35:26.669+03:00'
blogger_id: tag:blogger.com,1999:blog-5849718801312198988.post-6606193284822942861
blogger_orig_url: http://paullysak.blogspot.com/2016/05/cross-version-testing-with-sbt.html
---

<p>I’d like to share my experience on testing versions compatibility with sbt. The system which had to be tested consists of server (Play application) and a client - library that exposes server functionality to other apps. Not all apps that use client library may be updated fast enough with new version of server, so before deploying new server version we must check that client versions which are in use currently keep working. Moreover, tests for the client should demonstrate using it in Play application. Therefore, 2 Play apps should run simultateously during the tests, often with different versions. Read on if you’re interested for solution for such task. </p> <h1 id="project-structure">Project structure</h1> <p>Both server, client and cross-version tests are sub-projects inside of common project. They share the same version via <code>version.sbt</code>. Here are the most important dirs and files:</p> <pre><code>/my-proj<br /> +-/project<br /> |  +-MyTestUtils.scala<br /> +-/my-client<br /> |  +-build.sbt<br /> +-/my-client-tests<br /> |  +-/my-server-launcher<br /> |  |  +-build.sbt<br /> |  +-/app<br /> |  +-/conf<br /> |  |  +-clientTest.conf<br /> |  |  +-clientTest.routes<br /> |  +-/it<br /> |  |  +-/scala<br /> |  +-build.sbt<br /> +-/my-server<br /> |  +-/app<br /> |  +-/conf<br /> |  +-build.sbt<br /> +-build.sbt<br /> +-version.sbt<br /></code></pre> <p><code>my-server</code> and <code>my-client</code> are nothing special, just regular Play project and regular Scala project. Other files deserve specific attention.</p> <h1 id="my-client-testsmy-server-launcherbuildsbt">my-client-tests/my-server-launcher/build.sbt</h1> <pre><code>name := "my-server-launcher"<br /><br />val serverVersion = System.getProperty("serverVersion")<br /><br />if(serverVersion != null) {<br />    libraryDependencies += "my.org" %% "my-server" % serverVersion<br />} else {<br />    libraryDependencies += "my.org" %% "my-server" % version.value<br />}<br /></code></pre> <p>This makes possible to launch specific version of server, as long as it’s available in artifactories known to your project. Stepping forward and assuming that <code>my-server-launcher</code> is known as <code>myServerLaucher</code> to root project:</p> <pre><code>sbt ";project myServerLauncher; run 9000" -DserverVersion=1.2.3<br /></code></pre>   <h1 id="my-client-testsbuildsbt">my-client-tests/build.sbt</h1> <pre><code>name := "my-client-tests"<br /><br />libraryDependencies ++= Seq(<br />  ws,<br />  "org.scalatestplus" %% "play" % "1.4.0" % "it,test"<br />)<br /><br />sourceDirectory in IntegrationTest := baseDirectory.value / "it"<br /><br />Keys.fork in IntegrationTest := true<br />javaOptions in IntegrationTest += "-Dconfig.resource=clientTest.conf"<br /><br />routesGenerator := InjectedRoutesGenerator<br /></code></pre> <p>As <code>my-client-tests</code> is a Play application which demostrates how to use <code>my-client</code>,  it requires usual Play configuration - like <code>routesGenerator</code>. Play plugin for this subproject is enabled in root project, I’ll describe that a bit later. Important point is that<code>Key.fork</code> is set to <code>true</code> - it enables to run fake app for <a href="https://www.playframework.com/documentation/2.4.x/ScalaFunctionalTestingWithScalaTest">integration/functional tests</a> with different config file then <code>my-server</code>. Otherwise javaOptions would be ignored.</p>   <h1 id="projectmytestutilsscala">project/MyTestUtils.scala</h1> <pre><code>import sbt.Keys._<br />import sbt._<br /><br />object MyTestUtils {<br />  private val serverPort = 9001<br />  lazy val acceptanceCommand: Command = Command.command("acceptance")({(state) =&gt;<br />    var s = state<br />    s = Command.process("project myServerLauncher", s)<br />    s = Command.process("set PlayKeys.playInteractionMode := play.sbt.StaticPlayNonBlockingInteractionMode", s)<br />    s = Command.process(s"run $serverPort", s)   <br />    s = Command.process("project myClientTests", s)<br />    val serverUrl = s"http://localhost:$serverPort"<br />    s = Command.process(s"""set javaOptions in IntegrationTest ++= Seq(""-DtestServerUrl=$serverUrl") """.trim, s)<br />    s = Command.process(s"it:test", s)<br />    s<br />  })<br />}<br /></code></pre> <p><code>MyTestUtils.acceptanceCommand</code> will be attached to root project and run the tests together with server. Sbt task wouldn’t work here because we need to execute Play <code>run</code> which is a command itself. Pay attention to <code>playInteractionMode</code> which makes Play app run in background, together with tests. Also important point is that <code>testServerUrl</code> environment variable is passed to the tests and can be used to correctly configure the client.</p> <h1 id="root-project-buildsbt">root project build.sbt</h1> <pre><code>name := "my-proj"<br /><br />scalaVersion := "2.11.7"<br />organization := "my.org"<br /><br />lazy val root = (project in file(".")).<br />aggregate(myServer,<br />  myClient,<br />  myClientTests).<br />settings(<br />  aggregate in test := false /*to avoid running tests from myClientTests in incorrect environment*/<br />  ).<br />configs(IntegrationTest).<br />settings(Defaults.itSettings: _*)<br /><br /><br />parallelExecution in Test := true<br />parallelExecution in IntegrationTest := false<br /><br />lazy val myServer = project.in(file("my-server"))<br /><br />lazy val myClient = project.in(file("my-client"))<br /><br />lazy val myServerLauncher = project.in(file("my-client-tests/my-server-launcher")).enablePlugins(PlayScala)<br /><br />lazy val myClientTests = project.in(file("my-client-tests")).<br />  enablePlugins(PlayScala).<br />  configs(IntegrationTest).<br />  settings(publish := {}).<br />  settings(Defaults.itSettings: _*).<br />  aggregate(myClient).<br />  settings(aggregate in test := false).<br />  dependsOn(myClient)<br /><br />commands += MyTestUtils.acceptanceCommand<br /></code></pre> <p>Here sub-projects gain the names that can be used in sbt and <code>acceptanceCommand</code> is configured. Now tests from <code>my-client-tests</code> can be launched with current version of <code>my-server</code>:</p> <pre><code>sbt publishLocal<br />sbt acceptance<br /></code></pre> <p>or with custom version of <code>my-server</code>:</p> <pre><code>sbt acceptance -DserverVersion=1.2.3<br /></code></pre> <p>In order to check that latest changes are compatible with old clients you can publish locally latest version of server,  checkout older version of <code>my-project</code> by tag and run <code>sbt acceptance</code> with freshly published latest version.</p>