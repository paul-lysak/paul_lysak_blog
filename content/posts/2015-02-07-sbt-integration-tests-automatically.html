---
#layout: post
title: 'SBT integration tests: automatically launch application'
date: '2015-02-07T14:16:00.001+02:00'
author: Paul Lysak
tags:
- integration test
- Scala
- sbt
modified_time: '2015-02-07T14:19:12.116+02:00'
blogger_id: tag:blogger.com,1999:blog-5849718801312198988.post-8277357359169589860
blogger_orig_url: http://paullysak.blogspot.com/2015/02/sbt-integration-tests-automatically.html
---

<p>I’d like to share my experience in automatic launch of tested web application in SBT (tested with version 0.13.6) before running integration tests and shutting it down after tests. That wasn’t very straight-forward and involved custom tasks creation. I’d be happy to hear about easier ways if you know some.</p> <p>SBT documentation about <a href="http://www.scala-sbt.org/0.13/docs/Testing.html">testing</a> describes how to enable integration tests and run custom code before them via <code>testOptions in IntegrationTest += Tests.Setup(...)</code>, but there’s a class visibility issue: this custom code resides in project definition code (project of project), so it has no direct access to project main classes - it is responsible for building main classes, so it has to be fully compiled before them. This leaves 2 options:</p> <ol><li>Move integration tests to separate project, where build definition depends on the project where main classes are defined.</li><li>Use dynamic class resolution - class which is to be launched should be referenced by string containing its name, and launched via SBT API: <code>sbt.Fork.java.fork(...)</code></li></ol> <p>I’ve choosen the 2nd option as it would keep the project structure small enough. However, this leaves an open question: how would custom pre-integration test code know the correct classpath? I’ve solved it via shared object (let’s name it “remote control”) which gets initialized in main code build, and later used to start/stop application in projects build. Here full source code of <code>my_project/project/Build.scala</code>:</p> <pre><code>import java.io.IOException<br />import java.net.URL<br />import sbt._<br />import Keys._<br />import scala.util.{Failure, Success, Try}<br /><br />//rather generic project build definition - enabling integration tests<br />object MyBuildBuild extends Build {<br />  lazy val root = Project(id = "my-project-id",<br />    base = file(".")).<br />    configs(IntegrationTest).<br />    settings(Defaults.itSettings : _*).<br />      settings(testOptions in IntegrationTest += Tests.Setup({_ =&gt; AppRunnerRemoteControl.start()})).<br />      settings(testOptions in IntegrationTest += Tests.Cleanup({_ =&gt; AppRunnerRemoteControl.stop()})).<br />      settings(parallelExecution in IntegrationTest := false)<br />}<br /><br />//the core part of solution - shared object<br />object AppRunnerRemoteControl {<br />  //receive class path from main build definition<br />  def setClassPath(cp: Seq[File]): Unit = {<br />    this.cp = cp<br />  }<br />  //in order to have remote control logs in same style as the build logs<br />  def setLog(log: Logger): Unit = {<br />    this.log = Option(log)<br />  }<br /><br />  def start(): Unit = {<br />    log.foreach(_.info("starting application ..."))<br />    val options = ForkOptions(outputStrategy = Some(StdoutOutput))<br />    //build classpath string<br />    val cpStr = cp.map(_.getAbsolutePath).mkString(":")<br />    val arguments: Seq[String] = List("-classpath", cpStr, "-Dmy.custom.property=myCustomValue")<br />    //Here goes the name of the class which would be launched<br />    val mainClass: String = "my.pkg.AppRunner"<br />    //Launch it. Pay attention that class name comes last in the list of arguments<br />    proc = Option(Fork.java.fork(options, arguments :+ mainClass))<br /><br />    //make sure application really started or failed before proceed to the tests<br />    waitForStart().recover({case e =&gt;<br />      stop()<br />      throw e<br />    }).get<br />  }<br /><br />  def stop(): Unit = {<br />    log.foreach(_.info(s"stopping application $proc ..."))<br />    //kill application<br />    proc.foreach(_.destroy())<br />    proc = None<br />  }<br /><br />  private def waitForStart(): Try[_] = {<br />    val maxAttempts = 10<br />    val u = new URL("http://localhost:8080")<br />    val c = u.openConnection()<br />    val result = (1 to maxAttempts).toStream map {i =&gt;<br />      log.foreach(_.info(s"connection attempt $i of $maxAttempts"))<br />      Try {c.connect()}} find {<br />      case Success(_) =&gt; true<br />      case Failure(e: IOException) =&gt; Thread.sleep(1000); false<br />      case Failure(_) =&gt; false<br />    }<br />    if(result.isEmpty)<br />      Failure(new RuntimeException(s"Failed to connect to application after $maxAttempts attempts"))<br />    else<br />      Success(None)<br />  }<br /><br />  var log: Option[Logger] = None<br />  var cp: Seq[File] = Nil<br />  var proc: Option[Process] = None<br />}<br /></code></pre> <p>In order to use these capabilities main build has to be amended as well. Here is excerpt from <code>my_project/build.sbt</code>:</p> <pre><code>lazy val integrate = taskKey[Unit]("Starts REST API server and runs integration tests")<br /><br />lazy val preIntegrationTests = taskKey[Unit]("Starts REST API server and runs integration tests")<br /><br />preIntegrationTests := {<br />  val cp: Seq[File] = (fullClasspath in IntegrationTest).value.files<br />  AppRunnerRemoteControl.setClassPath(cp)<br />  AppRunnerRemoteControl.setLog(streams.value.log)<br />}<br /><br />integrate := {<br />  preIntegrationTests.value<br />  (test in IntegrationTest).value<br />}<br /></code></pre> <p>Now you may run this command to start the application, run integration tests, and stop the application:</p> <pre><code>sbt integrate<br /></code></pre> <p>Initially I was planning to have just one custom task - <code>integrate</code>. But it turned out that macroses used during defining tasks make sure that all dependencies of the tasks are invoked before running the tasks - not at the moment when they’re mentioned in task code. So the following code:</p> <pre><code>integrate := {<br />    val cp: Seq[File] = (fullClasspath in IntegrationTest).value.files<br />    AppRunnerRemoteControl.setClassPath(cp)<br />    AppRunnerRemoteControl.setLog(streams.value.log)<br />    (test in IntegrationTest).value<br />}<br /></code></pre> <p>would first run integration tests code (<code>(test in IntegrationTest).value</code>), as <code>integrate</code> depends on that task. And only then run code of <code>integrate</code> itself which should run the application for testing.</p>
