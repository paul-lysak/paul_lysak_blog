---
#layout: post
title: JavaScript deferreds are almost monads
date: '2013-01-04T18:33:00.001+02:00'
author: Paul Lysak
tags:
- JavaScript
- Haskel
- Functional programming
modified_time: '2013-01-14T12:43:53.270+02:00'
blogger_id: tag:blogger.com,1999:blog-5849718801312198988.post-6487811807508224164
blogger_orig_url: http://paullysak.blogspot.com/2013/01/javascript-deferreds-are-almost-monads.html
years: ['2013']
---

When I was learning monad concept from functional programming I suddenly realized that deferred objects avaiable in some JavaScript libraries (for example in Dojo - <a href="http://livedocs.dojotoolkit.org/dojo/Deferred">http://livedocs.dojotoolkit.org/dojo/Deferred</a>) are strikingly similar to monads.<br />Haskel has the clearest definition of the monads so let's start from it (don't get scarried, I'll explain essentials later):<br /><br /><pre><code>class  Monad m  where<br />     (&gt;&gt;=)            :: m a -&gt; (a -&gt; m b) -&gt; m b<br />     (&gt;&gt;)             :: m a -&gt; m b -&gt; m b<br />     return           :: a -&gt; m a<br />     fail             :: String -&gt; m a<br /></code></pre>In short words monad is a container type that aims to facilitate operations chaining. The key point is here (other lines either prepare data for it or provide syntatcic sugar):  <br /><pre><code>(&gt;&gt;=)            :: m a -&gt; (a -&gt; m b) -&gt; m b<br /></code></pre>It defines signature of operator &gt;&gt;=. It takes two arguments: 'm a' (data of type 'a' wrapped into monad of type 'm') and 'a -&gt; m b' (function that takes data of type 'a' and returns data of type 'b' wrapped into monad 'm'). And this operator returns 'm b' (data of type 'b' wrapped into monad of type 'm'). With such operation defined we can build a chain of dependent calculations without calling them immediately. What is even more important is that operations which stands earlier in the chain can abort calculation if it wants. For example, we can use monad <a href="http://www.haskell.org/haskellwiki/Maybe">Maybe</a> to indicate that data wasn't found. Then with properly defined functions we could write something like this: <br /><pre><code>(getCountryData "Country") &gt;&gt;= (getRegionData "Region") &gt;&gt;= (getCityData "City")<br /></code></pre>If country wasn't found then getRegionData and getCityData will not be called - a 'Nothing' instance would be returned immediately.   Now let's see what Deferred object from Dojo gives us (the same more or less applies to <a href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a>). It has method 'then' which accepts two functions - success handler and failure handler. Deferred object can be resolved (that means success) or rejected (that means failure). On resolving/rejecting some value may be provided which is passes as argument to appropriate handler. Handler can return another deferred if he wants. And the key point here is that 'then' method of deferred object also returns a deferred object - either original or replaced by previous handlers. That gives us ability to chain handlers and abort computations if necessary. Let's imagine how the same example would look in JavaScript:  <br /><pre><code>dojo.xhrGet({url: "server?country=Country"}).then( <br />  function(countryData) {return dojo.xhrGet({url: "server?region=Region"});}).then(<br />  function(regionData) {return dojo.xhrGet({url: "server?city=City"});}).then(<br />  function(cityData) { ...process city data here...});<br /></code></pre>Calls to dojo.xhrGet return deferred objects which are resolved on successful complete of HTTP request or rejected on HTTP request failure. Each handler receives data from previous steps. And each deferred object can terminate the whole workflow if it can't retrieve the data.   <br /><br />Let's recap similarities:<br /><div><ol><li>Both monads and deferreds can build chains of operations where each operation takes input from previous operation result.</li><li>If some operation cant provide data for next operation it can terminate the workflow&nbsp;</li><li>The workflow aren't necessary started immediately. They can be first built (possibly even in few different places) and then run.</li></ol>But there are also few differences due to which deferreds are not exactly monads:<br /><div></div><div><ol><li>Monads don't have separate handler for failure case - they just terminate the workflow.</li><li>&nbsp;Unlike monads deferreds don't have returned value. They have something that they can pass to next handler, but value from the last handler is lost. If you need that value you should attach yet another handler and process the value there - not a functional approach as it relies on side-effects.</li><li>As the consequence - in order to launch monadic workflow we request value from final monad (pull the tail), whilst for deferred we resolve or reject the initial deferred (push the head).</li><li>Another consequence - monads are synchronous and deferreds - asynchronous. When you request the value from monad you get operations executed and value returned. When you resolve the deferred your code continues and triggered workflow runs in background</li></ol></div></div>
