---
#layout: post
title: Dependency management in JavaScript
date: '2011-10-25T11:57:00.000+03:00'
author: Paul Lysak
tags:
- JavaScript
- modules
modified_time: '2011-11-11T19:11:46.533+02:00'
blogger_id: tag:blogger.com,1999:blog-5849718801312198988.post-2251119710384043874
blogger_orig_url: http://paullysak.blogspot.com/2011/10/dependency-management-in-javascript.html
years: ['2011']
---

Imagine web-application with lots of JavaScript code and CSS files which depend on each other. <br />Each page needs specific JS and CSS files, but it's not always easy to say which exactly - pages are constructed from relatively independent parts.<br />Moreover, some content which needs JS may be loaded asynchronously.<br />So, I'm goin to make some research about flexible ways of dependency management with JavaScript and blog about it.<br /><br /><br /><br /><span style="font-size: large;">RequireJS</span><span style="font-size: small;"> </span><br />(<a href="http://requirejs.org/">requirejs.org</a>, <a href="https://github.com/jrburke/requirejs">https://github.com/jrburke/requirejs</a>)<br /><br />An implementation of CommonJS AMD (asynchronous module definition) specification (<a href="http://www.commonjs.org/specs/">http://www.commonjs.org/specs/</a>)<br />There are quite a few similar solutions which differ in minor details - see <a href="http://www.commonjs.org/impl/">http://www.commonjs.org/impl/</a><br />Seems to have rather high development activity. Script size: 77.8kb uncompressed, 12.4kb compressed.<br /><br />At its simplest RequireJS can be used in a following way.<br />Include RequireJS script in your page:<br /><pre><code><br />&lt;script src="scripts/require.js"&gt;  <br />&lt;/script&gt;  <br /></code></pre>Somewhere in the scripts in you page call RequireJS functionality specifying modules list and a callback which should be called after modules load:<br /><pre><code>require(["some/module", "a.js", "b.js"], function(someModule) {<br />//this would run after requirements have been loaded<br />//some/module is retrieved by convention from some/module.js <br />});<br /></code></pre>However, recommended approach is to specify main file when including RequireJS:<br /><pre><code><br />&lt;script data-main="scripts/main" src="scripts/require.js"&gt;<br />&lt;/script&gt;<br /></code></pre><br />RequireJS allows to define modules. A module is an isolated namespace located in separate .js file which can have dependencies to another modules.<br />Usually module takes a whole .js file.<br />To me it look like a kind of dependency injection - modules receive references to their dependencies from outside.<br />Here is an example of module definition:<br /><br /><pre><code><br />define("my_module", //module name<br />["my_widget", "my_messages"], //module dependencies <br />  function(widget, messages) {<br />  //This is a module function. Whatever it returns becames module content.<br />  //Its dependencies my_widget and my_messages generally should have similar function too,<br />  //values they return became respective module content and are passed as 'widget' and 'messages' parameters to this function. <br />  //By the time this function is called it's guaranteed that my_widget and my_messages have been already loaded<br />  return {<br />    msg: "hello, world!",<br />    show: function() {alert(this.msg)}<br />    //other code which may use widget and messages<br />    }<br />  }<br />}<br />);<br /></code></pre><br />So, dependencies are defined inside a script which needs them - there's no central place which lists all dependencies.<br />On the one hand this simplifies developers collaboration (everyone can foccus on changes inside his own module), but on the other hand<br />it can be better not to modify some files (for example, third-party libraries) as it would complicate their upgrade at later time.<br /><br /><br />By default, for same hierarchy level script loading order is not guaranteed. This is not a problem for modules as they should<br />interact only through dependencies passed to their functions. But plain .js files may expect some loading order so that global<br />workspace would be prepared correctly. Usually it's possible to guarantee order with following syntax:<br /><pre><code><br />require(["order!one.js", "order!two.js", "order!three.js"], function () {<br />//This callback is called after the three scripts finish loading.<br />});<br /></code></pre>However, there are some limitations - see RequireJS API for details. <br /><br />RequireJS has no explicit support for CSS files loading. As they explain on their FAQ page (<a href="http://requirejs.org/docs/faq-advanced.html#css">http://requirejs.org/docs/faq-advanced.html#css</a>)<br />some browsers don't allow to determine when CSS file was loaded, so code that relies on elements style (size, position, etc.) can be broken.<br />FAQ also includes an example of CSS loading functions for those who don't care about loading order.<br />Modules may load CSS files content as their dependencies using "text!" modifier - see API (<a href="http://requirejs.org/docs/api.html#text">http://requirejs.org/docs/api.html#text</a>).<br /><br /><br /><br /><span style="font-size: large;">Jingo</span><br />(<a href="http://code.google.com/p/jingo/">http://code.google.com/p/jingo/</a>)<br /><br />More or less functionaly similar to RequireJS but has slightly different syntax. Project doesn't have any activity since November 2009.<br />Script size: 31.2kb uncompressed, 7.6kb compressed.<br /><br />That's how one would declare 'hallmart.Store' module which references 'hallmart.Greeter'<br /><pre><code><br />jingo.declare({<br />  require: [ //here goes list of required modules<br />    'my_required_module',<br />    'another_required_module'<br />  ],<br />  name: 'my_requiring_module', //a name of declared module<br />  as: function() {<br />    //here goes the body of the module.<br />    //It will be executed  after loading of all dependencies<br />  }<br />});<br /></code></pre>Unlike RequireJS Jingo doesn't use result returned by module body function (method 'as'),<br />neither does it provide references to modules loaded as requirements (simply because their body function result is either discarded).<br />So, cooperation between modules uses global namespace. <br /><br />In order to use modules in some page one should define anonymous module which references all the necessary dependencies:<br /><pre><code><br />jingo.anonymous({<br />  require: [<br />    'firstLibraryModule',<br />    'secondLibraryModule'<br />  ],<br />  exec: function() {<br />  //This will run after all requirements are loaded.<br />  //Optional, can be skipped if all work is done by depencencies <br />  }<br />});<br /></code></pre><br />Documentation doesn't mention any CSS loading support. <br /><br /><br /><br /><br /><span style="font-size: large;">Pyramid-js</span><br />(<a href="http://code.google.com/p/pyramidjs/">http://code.google.com/p/pyramidjs/</a>, <a href="http://joel.inpointform.net/software-development/pyramid-js-a-web-dependency-manager/">http://joel.inpointform.net/software-development/pyramid-js-a-web-dependency-manager/</a>)<br /><br />Rather recent - appeared on code.google in year 2011. Uncompressed script size - 19.8kb. Compressed script isn't provided by author.<br /><br />This dependency manager takes a different approach. All dependencies are supposed to be declared in one .js file:<br /><pre><code><br />Pyramid.rootPath = './'; //where from load dependencies<br />//Set up file dependencies<br />Pyramid.newDependency({//declare dependency with couple of .js files<br />name: 'jquery',<br />files: ['jquery.js', 'jquery-ui.js']<br />});<br />Pyramid.newDependency({//declare dependency with both .js and .css files<br />name:'myWidget',<br />files: ['myWidgetStyle.css', 'myWidgetCode.js']<br />});<br />Pyramid.newDependency({<br />name:'main',<br />files: ['init.js'],<br />dependencies: ['jquery','myWidget']<br />});<br /></code></pre><br /><br />And then page should include PyramidJS, dependencies file and call Pyramid API to load main module: <br /><br /><pre><code><br />&lt;script src="standardResources/Pyramid-1.0.1.js" type="text/javascript"&gt;<br />&lt;/script&gt;<br />&lt;script src="dependencies.js" type="text/javascript"&gt;<br />&lt;/script&gt;<br />&amp;ltscript type="text/javascript"&gt;<br /> Pyramid.load('main');<br />&lt;/script&gt;<br /></code></pre><br />Unfortunately, there are no callbacks available to run some code when module has been loaded. If you need to run some code when module A has loaded<br />you need to place it in module B and specify in requirements file that B depends on A. <br /><br />As you can see, PyramidJS supports CSS inclusion, but this feature should be used with caution. When PyramidJS needs to apply CSS file it just adds  tag with appropriate "href" property.<br />So, There is no way to find out when styles have finished loading. This should be kept in mind when manipulating DOM from javascript at load time as styles may<br />be not applied by the that moment. <br /><br /><br /><br /><span style="font-size: large;">YUI3 modules</span> <br />(<a href="http://yuilibrary.com/yui/docs/yui/">http://yuilibrary.com/yui/docs/yui/</a>)<br /><br />YUI toolkit provides this feature among others. Size of script needed for modules loading: 268kb uncompressed, 66.4 kb compressed.<br />But in addition to this script YUI asynchronously loads few more which are needed in order to perform basic functions.<br />Approach taken by YUI is rather close to one of PyramidJS: first declare requirements tree in some specific place, then call YUI API to load modules tree.<br />Modules are defined in general YUI configuration object - the one which is passed to YUI object creation function. This looks like following:<br /><br /><pre><code><br />&lt;script src="yui/build/yui/yui.js"&gt;<br />&lt;/script&gt;<br />&lt;script&gt;<br />YUI({modules: {<br />  script1: {fullpath: "script1.js", requires: ["script2"]},<br />  script2: {fullpath: "script2.js", requires: ["styles"]},<br />  styles: {fullpath: "style1.css", type: "css"}<br /> }}).use("script1", function(Y) {<br />   //Optional - callback which will run after all dependencies are loaded<br />   //Takes YUI object as argument<br /> });<br />&lt;/script&gt;<br /></code></pre><br />Pay attention that YUI also supports CSS loading - developer just needs to specify module type.<br />CSS is applied by inserting new  tags with "href" - not with content.<br />Nevertheless, documentation claims that YUI can recognize when CSS loading finishes, guarantees that CSS files of the same dependency level will be loaded prior to .js files and even add some callback to such event<br />(<a href="http://yuilibrary.com/yui/docs/api/classes/Loader.html">http://yuilibrary.com/yui/docs/api/classes/Loader.html</a>), but doesn't say how do they do it. I tried to debug a little to find out <br />how did they bypass standard limitations but this part is very complicated. <br /><br />In order to have a real module which integrates in YUI infrastructure, not just plain asynchronously included file,<br />.js files which contain modules should look like this:<br /><pre><code><br />YUI.add('mymodules-mod1', function(Y) {<br />//this function is executed after call to YUI.use <br />//Y argument is the YUI object instance for which 'use' method has been called <br />Y.namespace('mynamespace');<br /><br />Y.mynamespace.Mod1 = function() {<br />// expose an API<br />};<br /><br />}, '0.1.1' /* module version */, {<br />requires: ['base'] //modules on which this module depends - I think it somewhat duplicates YUI object configuration<br />});<br /></code></pre><br /><span style="font-size: large;"> CurlJS </span><br />(<a href="https://github.com/unscriptable/curl">https://github.com/unscriptable/curl</a>)<br /><br /><br />CurlJS is a part of a bigger set of javascript tools - CujoJS (http://cujojs.com/). This loader sticks to AMD-type modules and mostly resembles RequireJS but it supports CSS loading and can guarantee that CSS files are loaded before execution of scripts - there are some tricks and workaround inside to make this work in all browsers.<br />It also sticks to promises-based API (http://wiki.commonjs.org/wiki/Promises) which allows more compact and comprehensive syntax.<br />Uncompressed size of minimal distribution: 21.2 kB, compressed: 5.12 kB. However, in order to handle CSS and non-moduled JS files correctly it needs plugins - 15.3 kB and 4.9 kB respectively, uncompressed.<br />So, let's keep in mind 41.4 kB as uncompressed size.<br /><br />This is typical example of CurlJS usage somewhere in HTML page:<br /><pre><code><br />&lt;script src="js/curl.js"&gt;&lt;/script&gt;<br />&lt;script&gt;<br /> curl(["js/myModule", "js/css!css/stylesheet.css"]).then(function(myModule, stylesheet) {<br />    console.log("Modules loaded", myModule, stylesheet);<br />   },<br />   function(ex) {<br />    console.log("Modules failed to load", ex);<br />   });<br />&lt;/script&gt;<br /></code></pre><br />Here "js/myModule" refers to file "js/myModule.js" which contains module definition and "js/css!" refers to CSS loading plugin<br />which resides in "js/css.js" file. Both myModule and stylesheet.css will be loaded prior to executing success callback function.<br /><br />myModule.js may look this way:<br /><pre><code><br />define(["js/myModule2", "js/js!js/legacyLib2.js", "js/js!js/legacyLib1.js", "js/css!css/moduleStylesheet.css"], //dependencies list<br /> function(mod2, lib2, lib1, modCss) {<br />  //here goes module body<br />  return {doSomething: function(alert("hello!")}; //this object will be passed to code that declares dependency on this module<br />});<br /></code></pre><br />All dependencies are guaranteed to be loaded before executing module body.<br />Here "js/myModule2" refers to another module (which calls 'define' internally) and "js/js!" refers to legacy JS loader plugin (placed at "js/js.js"),<br />without this plugin CurlJS would expect that 'define' is called somewhere and will be very disappointed when it finds no calls. So,<br />"js/js!js/legacyLib1.js" and "js/js!js/legacyLib2.js" refere to some third-party libraries which don't contain modules and don't call 'define'.<br />And, as you can see, modules can also depend on CSS stylesheets. <br /><br />Later in the same page it's safe to ask for the same modules:<br /><pre><code><br />curl(["js/myModule"]).then(function(myModuleAgain) {<br /> console.log("Modules loaded again", myModuleAgain);<br />});<br /></code></pre><br />Neither JS file will be loaded again, nor module body executed - CurlJS will just take what the module body has returned when it was called first time<br />and pass it through myModuleAgain to handler function.<br /><br /><br /><br /><span style="font-size: large;">Let's put it all together</span><br /><br /><table class="contentTable"><tbody><tr> <th></th> <th>RequireJS</th> <th>Jingo</th> <th>PyramidJS</th> <th>YUI modules</th> <th>CurlJS</th></tr><tr> <td>size (uncompressed)</td> <td>77.8k</td> <td>31.2k</td> <td>19.8k</td> <td>&gt;268kb</td> <td>41.4k</td> </tr><tr> <td>maturity</td> <td>high</td> <td>medium</td> <td>low</td> <td>high</td> <td>medium</td> </tr><tr>  <td>development activity</td> <td>high</td> <td>low</td> <td>medium</td> <td>high</td> <td>high</td> </tr><tr> <td>depencency configuration</td> <td>in modules</td> <td>in modules</td> <td>centralized</td> <td>combined</td> <td>in modules</td> </tr><tr> <td>CSS support</td> <td>no</td> <td>no</td> <td>partly</td> <td>yes</td> <td>yes</td> </tr><tr> <td>module incapsulation</td> <td>full</td> <td>partial</td> <td>no</td> <td>partial</td> <td>full</td></tr></tbody></table><br /><br />That's all for now. I would appreciate comments and suggestions about these or, possibly, better libraries.
