---
#layout: post
title: 'Antipatterns: initialization after usage'
date: '2012-12-19T19:19:00.000+02:00'
author: Paul Lysak
tags:
- antipatterns
- patterns
modified_time: '2012-12-19T19:19:30.308+02:00'
blogger_id: tag:blogger.com,1999:blog-5849718801312198988.post-6625293038928616917
blogger_orig_url: http://paullysak.blogspot.com/2012/12/antipatterns-initialization-after-usage.html
---

I've seen such problem fiew times and I'm going to describe it as an antipattern - let's call it "initialization after usage". It could sound a bit like Captain Obvious, but isn't it typical for some pattern/antipattern catalogs? :)<br /><br /><h3>The problem:</h3>There is an object which has some fields initialized in one place, some in completely different place, and in the meantime the object is used somewhere. So when using the object it's not clear if its fields are completely initialized or not. <br /><br />As an example - let's see Java object:<br /> <pre><code><br />public class Person {<br />  private String firstName;<br />  private String lastName;<br />  private String postalIndex;<br />  private String city;<br />  public Person(String firstName, String lastName, String postalIndex) {<br />//apply values here<br /> }<br />//getters and setters go here<br />}<br /></code></pre>Its fields firstName, lastName and postalIndex are initialized immediately. The city is searched a lot later in some database by index and gets assigned later. In the meantime Person object can be displayed on some page, saved to DB etc., and during these operations nobody can be sure if city field is available or not.<br /><br />Notice that problem doesn't apply to lazy-loaded or lazy-initialized fields as they can be retrieved on demand. <br />I'm also not talking about objects where some fields may not be applicable due to domain-specific concerns.<br />I'm talking just about fields that are set by some external systems that can't be controlled by the object itself and which always make sense from business point of view. Like in the example - if Person has a postalIndex then there's certainly some city assotiated with it (all right, could as well be village).<br /><br /><h3>Possible solutions:</h3><ol><li>Initialize all the fields immediately. However this may not be the option sometimes due to costly initialization of data which aren't used in all the cases.</li><li>Factor out initialization to some utility method of another class. This is possible only if object contain enough information to build missing part, possibly with using external services.</li><li>Move out fields to a wrapping class which maintains link to original object. Then in the second phase of initialization wrapped class instance would be created and used whereever additional fields needed. But this could be an overkill in some cases. A rather contrieved example could be like this (here it's definitely overkill, but it shows an approach):</li><pre><code><br />public class PersonAddress {<br />  private Person person;<br />  private String city;<br />//constructors, getters, setters go here<br />}<br /></code></pre><li>Modification of point 3 - subclass from original class </li></ol>
